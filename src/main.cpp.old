#include <chrono>
#include <cstdlib>
#include <iostream>
#include <thread>
#include <unistd.h>
#include <wayland-server-protocol.h>
#include <wayland-util.h>
extern "C" {
#include <linux/input-event-codes.h>
#include <wayland-server-core.h>
#include <wlr/backend.h>
#include <wlr/interfaces/wlr_keyboard.h>
#include <wlr/render/allocator.h>
#include <wlr/types/wlr_compositor.h>
#include <wlr/types/wlr_cursor.h>
#include <wlr/types/wlr_data_device.h>
#include <wlr/types/wlr_keyboard.h>
#include <wlr/types/wlr_output.h>
#include <wlr/types/wlr_output_layout.h>
#include <wlr/types/wlr_subcompositor.h>
#include <wlr/types/wlr_xdg_shell.h>
#include <wlr/util/log.h>
#define static
#include <wlr/types/wlr_scene.h>
#undef static

#include <xkbcommon/xkbcommon.h>
}
using namespace std;

#define MAKE_SERVER_CALLBACK(publicName)                                       \
  static void handle##publicName(wl_listener *listener, void *data) {          \
    WaylandServer *server =                                                    \
        wl_container_of(listener, server, m_##publicName##Listener);           \
    server->m_new##publicName(data);                                           \
  }
#define MAKE_OUTPUT_CALLBACK(publicName)                                       \
  static void handle##publicName(wl_listener *listener, void *data) {          \
    WaylandOutput *output =                                                    \
        wl_container_of(listener, output, m_##publicName##Listener);           \
    output->m_new##publicName(data);                                           \
  }

class WaylandServer {
private:
  struct wl_display *m_display;
  struct wlr_backend *m_backend;
  struct wlr_renderer *m_renderer;
  struct wlr_allocator *m_allocator;
  struct wl_event_loop *m_eventLoop;
  struct wlr_output_layout *m_outputLayout;
  struct wl_list m_outputs_l;
  struct wl_listener m_OutputListener;

  struct wlr_scene *m_scene;
  struct wlr_scene_output_layout *m_sceneLayout;

  struct wl_list m_topLevels_l;
  struct wl_listener m_TopLevelListener;
  struct wl_listener m_TopLevelPopupListener;

  struct wlr_xdg_shell *m_xdgShell;

  struct wlr_cursor *m_cursor;
  struct wl_listener m_CursorMotionListener;
  struct wl_listener m_CursorMotionAbsoluteListener;
  struct wl_listener m_CursorButtonListener;
  struct wl_listener m_CursorAxisListener;
  struct wl_listener m_CursorFrameListener;

  struct wl_list m_keyboards_l;
  struct wlr_seat *m_seat;

  struct wl_listener m_InputListener;
  struct wl_listener m_CursorListener;
  struct wl_listener m_CursorSelectionListener;

  struct wl_listener m_KeyboardInputListener;

  class WaylandOutput {
  private:
    wl_list m_link;
    WaylandServer *m_server;
    wlr_output *m_output;
    wl_listener m_FrameListener;
    wl_listener m_StateRequestListener;
    wl_listener m_DestroyRequestListener;

    void m_newFrame(void *data) {
      // This is the rendering loop.
      struct wlr_scene_output *scene_output =
          wlr_scene_get_scene_output(m_server->m_scene, m_output);

      // Render the scene if needed.
      if (!wlr_scene_output_commit(scene_output, NULL)) {
        return;
      }

      // Send a frame done event to the client.
      struct timespec now;
      timespec_get(&now, TIME_UTC);
      wlr_scene_output_send_frame_done(scene_output, &now);
      //
    }
    void m_newStateRequest(void *data) {
      // Used for changing the state of an ouput, depending on the output's
      // request.
      std::cout << "Received a State Request!" << std::endl;
      //
      auto *event =
          static_cast<const struct wlr_output_event_request_state *>(data);
      // The host compositor is asking us to change our mode . We just need to
      // accept it by committing the suggested state.
      wlr_output_commit_state(m_output, event->state);
    }
    void m_newDestroyRequest(void *data) {
      std::cout << "Received a Destroy Request!" << std::endl;
      //
    }

  public:
    MAKE_OUTPUT_CALLBACK(Frame);
    MAKE_OUTPUT_CALLBACK(StateRequest);
    MAKE_OUTPUT_CALLBACK(DestroyRequest);
    WaylandOutput(WaylandServer *parentServer, wlr_output *output) {
      m_output = output;
      m_FrameListener.notify = handleFrame;
      m_server = parentServer;
      wl_signal_add(&m_output->events.frame, &m_FrameListener);
      m_StateRequestListener.notify = handleStateRequest;
      wl_signal_add(&m_output->events.request_state, &m_StateRequestListener);
      m_DestroyRequestListener.notify = handleDestroyRequest;
      wl_signal_add(&m_output->events.destroy, &m_DestroyRequestListener);
      wl_list_insert(&parentServer->m_outputs_l, &m_link);

      // Adds a the new output from left to right because i'm fucking lazy.
      struct wlr_output_layout_output *layoutOutput =
          wlr_output_layout_add_auto(parentServer->m_outputLayout, m_output);

      struct wlr_scene_output *sceneOutput =
          wlr_scene_output_create(parentServer->m_scene, m_output);

      wlr_scene_output_layout_add_output(parentServer->m_sceneLayout,
                                         layoutOutput, sceneOutput);
    }
  };

  class TopLevelView {
  private:
    WaylandServer *m_server;
    wlr_xdg_toplevel *m_topLevel;
    wlr_scene_tree *m_sceneTree;

    wl_listener m_MapListener;
    wl_listener m_UnmapListener;
    wl_listener m_DestroyListener;
    wl_listener m_CommitListener;
    int fullscreenAttempts = 0;
    int maximumFullscreenAttemptAmount = 10;

    void m_newMap(void *data) {
      m_sceneTree->node.enabled = true;
      wlr_seat_keyboard_notify_enter(m_server->m_seat,
                                     m_topLevel->base->surface, NULL, 0, NULL);
    }
    void m_newUnmap(void *data) {
      std::cout << "Ignoring unmap request" << std::endl;
    }

    void m_newDestroy(void *data) {
      std::cout << "Ignoring destroy request" << std::endl;
    }

    void m_newCommit(void *data) {
      if (!m_topLevel->base->initial_commit &&
          (fullscreenAttempts++ > maximumFullscreenAttemptAmount)) {
        return;
      }
      std::cout << "Received commit request" << std::endl;
      configureFullScreen();

      // 5. Set focus.
      wlr_xdg_toplevel_set_activated(m_topLevel, true);
      double sx, sy;
      struct wlr_scene_node *node = wlr_scene_node_at(
          &m_server->m_scene->tree.node, m_server->m_cursor->x,
          m_server->m_cursor->y, &sx, &sy);
      wlr_seat_pointer_notify_enter(m_server->m_seat, m_topLevel->base->surface,
                                    sx, sy);

      auto *keyboard = wlr_seat_get_keyboard(m_server->m_seat);
      if (keyboard) {
        wlr_seat_keyboard_notify_enter(
            m_server->m_seat, m_topLevel->base->surface, keyboard->keycodes,
            keyboard->num_keycodes, &keyboard->modifiers);
      }
    }

  public:
    wl_list m_link;

#define MAKE_TOPLEVEL_CALLBACK(publicName)                                     \
  static void handle##publicName(wl_listener *listener, void *data) {          \
    TopLevelView *view =                                                       \
        wl_container_of(listener, view, m_##publicName##Listener);             \
    view->m_new##publicName(data);                                             \
  }

    MAKE_TOPLEVEL_CALLBACK(Map);
    MAKE_TOPLEVEL_CALLBACK(Unmap);
    MAKE_TOPLEVEL_CALLBACK(Destroy);
    MAKE_TOPLEVEL_CALLBACK(Commit);

    void configureFullScreen() {
      // 1. Reliably get the primary (and only) output from the layout.
      // We don't ask the client where it is; we find the display ourselves.
      struct wlr_output *output =
          wlr_output_layout_get_center_output(m_server->m_outputLayout);
      if (!output) {
        wlr_log(WLR_ERROR,
                "Could not find an output to place the toplevel on.");
        return;
      }

      // 2. Get the exact dimensions and position of that output in the layout.
      // This is the authoritative geometry we will enforce.
      struct wlr_box output_box;
      wlr_output_layout_get_box(m_server->m_outputLayout, output, &output_box);

      // 3. Configure the client to be fullscreen and match the output size.
      wlr_xdg_toplevel_set_fullscreen(m_topLevel, true);
      wlr_xdg_toplevel_set_size(m_topLevel, output_box.width,
                                output_box.height);
      // 4. Position our scene node to align perfectly with the output.
      wlr_scene_node_set_position(&m_sceneTree->node, output_box.x,
                                  output_box.y);
    }
    TopLevelView(WaylandServer *server, wlr_xdg_toplevel *toplevel) {
      m_server = server;
      m_topLevel = toplevel;

      // Add this view to the server's list of toplevels
      wl_list_insert(&server->m_topLevels_l, &m_link);

      // Create a scene graph node for this toplevel.
      // The scene graph will manage rendering the surface.
      m_sceneTree =
          wlr_scene_xdg_surface_create(&server->m_scene->tree, toplevel->base);

      // Initially, the window is not mapped/visible.
      m_sceneTree->node.enabled = false;

      // Set up listeners for the toplevel's lifecycle events.
      m_MapListener.notify = handleMap;
      wl_signal_add(&m_topLevel->base->surface->events.map, &m_MapListener);

      m_UnmapListener.notify = handleUnmap;
      wl_signal_add(&m_topLevel->base->surface->events.unmap, &m_UnmapListener);

      m_DestroyListener.notify = handleDestroy;
      wl_signal_add(&m_topLevel->events.destroy, &m_DestroyListener);

      m_CommitListener.notify = handleCommit;
      wl_signal_add(&m_topLevel->base->surface->events.commit,
                    &m_CommitListener);
    }
  };

  void m_newOutput(void *data) {
    std::cout << "New output detected" << std::endl;
    auto *output = static_cast<struct wlr_output *>(data);

    // Need to handle the start the output
    wlr_output_init_render(output, m_allocator, m_renderer);
    struct wlr_output_state state;
    wlr_output_state_init(&state);
    wlr_output_state_set_enabled(&state, true);

    // Set the output mode (resolution and refreshrate and shit).
    // TODO: Set it to a custom resolution.
    struct wlr_output_mode *mode = wlr_output_preferred_mode(output);
    if (mode != NULL) {
      wlr_output_state_set_mode(&state, mode);
    }

    wlr_output_commit_state(output, &state);
    wlr_output_state_finish(&state);

    // This will manage itself i hope.
    WaylandOutput *newOutput = new WaylandOutput(this, output);
  }

  void m_newTopLevel(void *data) {
    std::cout << "New toplevel detected" << std::endl;
    auto *topLevel = static_cast<struct wlr_xdg_toplevel *>(data);
    auto *newView = new TopLevelView(this, topLevel);
  }
  void m_newTopLevelPopup(void *data) {
    std::cout << "New toplevel detected" << std::endl;
  }
  void m_newCursorMotion(void *data) {
    std::cout << "\rNew cursorMotion detected" << std::endl;
    auto *mouseEvent = static_cast<struct wlr_pointer_motion_event *>(data);

    wlr_cursor_move(m_cursor, &mouseEvent->pointer->base, mouseEvent->delta_x,
                    mouseEvent->delta_y);
    double sx, sy;
    wlr_surface *surface = NULL;
    auto *node = wlr_scene_node_at(&m_scene->tree.node, m_cursor->x,
                                   m_cursor->y, &sx, &sy);
    wlr_seat_pointer_notify_motion(m_seat, mouseEvent->time_msec, sx, sy);
  }
  void m_newCursorMotionAbsolute(void *data) {
    std::cout << "New cursorMotionAbsolute detected" << std::endl;

    auto *mouseEvent =
        static_cast<struct wlr_pointer_motion_absolute_event *>(data);

    // Make sure the cursor doesn't get offsetted too far.
    wlr_cursor_warp_absolute(m_cursor, &mouseEvent->pointer->base,
                             mouseEvent->x, mouseEvent->y);
  }

  void m_newCursorButton(void *data) {
    std::cout << "New cursorButton detected" << std::endl;
    auto *mouseEvent = static_cast<struct wlr_pointer_button_event *>(data);

    wlr_seat_pointer_notify_button(m_seat, mouseEvent->time_msec,
                                   mouseEvent->button, mouseEvent->state);
  }
  void m_newCursorAxis(void *data) {
    std::cout << "New cursorAxis detected" << std::endl;
  }
  void m_newCursorFrame(void *data) {
    std::cout << "New cursorFrame detected" << std::endl;
  }

  void handleNewKeyboard(wlr_input_device *device) {

    wlr_keyboard *keyboard;
    std::cout << "New keyboard detected" << std::endl;
    keyboard = wlr_keyboard_from_input_device(device);
    auto *xkbContext = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
    auto *xkbKeymap = xkb_keymap_new_from_names(xkbContext, NULL,
                                                XKB_KEYMAP_COMPILE_NO_FLAGS);

    // Setup the keyboard to also send keysyms alongside input.
    wlr_keyboard_set_keymap(keyboard, xkbKeymap);
    xkb_keymap_unref(xkbKeymap);
    xkb_context_unref(xkbContext);
    wlr_keyboard_set_repeat_info(keyboard, 25, 600);

    wlr_seat_set_keyboard(m_seat, keyboard);
    m_KeyboardInputListener.notify = handleKeyboardInput;
    wl_signal_add(&keyboard->events.key, &m_KeyboardInputListener);

    // TODO: Add keyboard modifiers handling?
  }

  void m_newInput(void *data) {
    std::cout << "New input detected" << std::endl;
    auto *device = static_cast<struct wlr_input_device *>(data);
    switch (device->type) {
    case WLR_INPUT_DEVICE_KEYBOARD:
      handleNewKeyboard(device);

      break;
    case WLR_INPUT_DEVICE_POINTER:
      std::cout << "New pointer detected" << std::endl;
      wlr_cursor_attach_input_device(m_cursor, device);
      break;
    default:
      break;
    };

    uint32_t capabilities =
        WL_SEAT_CAPABILITY_POINTER | WL_SEAT_CAPABILITY_KEYBOARD;
    wlr_seat_set_capabilities(m_seat, capabilities);
  }
  void m_newCursor(void *data) {
    std::cout << "New cursor detected" << std::endl;
  }
  void m_newCursorSelection(void *data) {
    std::cout << "New cursorSelection detected" << std::endl;
  }

  void m_newKeyboardInput(void *data) {
    std::cout << "New keyboard input detected" << std::endl;

    auto *event = static_cast<struct wlr_keyboard_key_event *>(data);
    auto *keyboard = wlr_seat_get_keyboard(m_seat);
    wlr_seat_keyboard_notify_modifiers(m_seat, &keyboard->modifiers);
    wlr_seat_keyboard_notify_key(m_seat, event->time_msec, event->keycode,
                                 event->state);
  }

public:
  MAKE_SERVER_CALLBACK(Output);
  MAKE_SERVER_CALLBACK(TopLevel);
  MAKE_SERVER_CALLBACK(TopLevelPopup);
  MAKE_SERVER_CALLBACK(CursorFrame);
  MAKE_SERVER_CALLBACK(CursorAxis);
  MAKE_SERVER_CALLBACK(CursorMotion);
  MAKE_SERVER_CALLBACK(CursorMotionAbsolute);
  MAKE_SERVER_CALLBACK(CursorButton);

  MAKE_SERVER_CALLBACK(Input);
  MAKE_SERVER_CALLBACK(Cursor);
  MAKE_SERVER_CALLBACK(CursorSelection);

  MAKE_SERVER_CALLBACK(KeyboardInput);

  const char *waylandSocket;

  WaylandServer() {
    m_display = wl_display_create();
    m_eventLoop = wl_display_get_event_loop(m_display);
    m_backend = wlr_backend_autocreate(m_eventLoop, NULL);

    m_renderer = wlr_renderer_autocreate(m_backend);

    wlr_renderer_init_wl_display(m_renderer, m_display);

    m_allocator = wlr_allocator_autocreate(m_backend, m_renderer);

    wlr_compositor_create(m_display, 5, m_renderer);
    wlr_subcompositor_create(m_display);
    wlr_data_device_manager_create(m_display);

    m_outputLayout = wlr_output_layout_create(m_display);

    wl_list_init(&m_outputs_l);

    m_OutputListener.notify = handleOutput;

    wl_signal_add(&m_backend->events.new_output, &m_OutputListener);

    m_scene = wlr_scene_create();
    m_sceneLayout = wlr_scene_attach_output_layout(m_scene, m_outputLayout);

    wl_list_init(&m_topLevels_l);
    m_xdgShell = wlr_xdg_shell_create(m_display, 3);
    m_TopLevelListener.notify = handleTopLevel;
    m_TopLevelPopupListener.notify = handleTopLevelPopup;
    wl_signal_add(&m_xdgShell->events.new_toplevel, &m_TopLevelListener);
    wl_signal_add(&m_xdgShell->events.new_popup, &m_TopLevelPopupListener);

    m_cursor = wlr_cursor_create();

    wlr_cursor_attach_output_layout(m_cursor, m_outputLayout);

    m_CursorMotionListener.notify = handleCursorMotion;
    m_CursorMotionAbsoluteListener.notify = handleCursorMotionAbsolute;
    m_CursorAxisListener.notify = handleCursorAxis;
    m_CursorButtonListener.notify = handleCursorButton;
    m_CursorFrameListener.notify = handleCursorFrame;

    wl_signal_add(&m_cursor->events.motion, &m_CursorMotionListener);
    wl_signal_add(&m_cursor->events.motion_absolute,
                  &m_CursorMotionAbsoluteListener);
    wl_signal_add(&m_cursor->events.axis, &m_CursorAxisListener);
    wl_signal_add(&m_cursor->events.button, &m_CursorButtonListener);
    wl_signal_add(&m_cursor->events.frame, &m_CursorFrameListener);

    // Configure seats
    wl_list_init(&m_keyboards_l);
    m_InputListener.notify = handleInput;
    wl_signal_add(&m_backend->events.new_input, &m_InputListener);

    m_seat = wlr_seat_create(m_display, "seat1");

    m_CursorListener.notify = handleCursor;
    m_CursorSelectionListener.notify = handleCursorSelection;
    wl_signal_add(&m_seat->events.request_set_cursor, &m_CursorListener);
    wl_signal_add(&m_seat->events.request_set_selection,
                  &m_CursorSelectionListener);
  };
  void start() {
    waylandSocket = wl_display_add_socket_auto(m_display);

    if (!waylandSocket) {
      wlr_backend_destroy(m_backend);
      wlr_log(WLR_ERROR, "Failed to initialise the wayland socket.");
      exit(EXIT_FAILURE);
    }

    /* Start the backend. This will enumerate outputs and inputs, become the DRM
     * master, etc */
    if (!wlr_backend_start(m_backend)) {
      wlr_backend_destroy(m_backend);
      wl_display_destroy(m_display);
      wlr_log(WLR_ERROR, "Failed to start the backend.");
      exit(EXIT_FAILURE);
    }

    /* Set the WAYLAND_DISPLAY environment variable to our socket and run the
     * startup command if requested. */
    setenv("WAYLAND_DISPLAY", waylandSocket, true);
    wlr_log(WLR_INFO, "Running Wayland compositor on WAYLAND_DISPLAY=%s",
            waylandSocket);
  }
  void loop() {
    wlr_log(WLR_DEBUG, "Running the main loop");
    while (1) {
      wl_event_loop_dispatch(m_eventLoop, -1);
      wl_display_flush_clients(m_display);
    }
  }

  wlr_seat *getSeatPointer() { return m_seat; }
};

void keyboardThread(wlr_seat *seat) {
  auto keyboard = wlr_seat_get_keyboard(seat);
  struct wlr_keyboard_key_event event = {
      .time_msec = 0,
      .keycode = KEY_W,
      .update_state = true,
      .state = WL_KEYBOARD_KEY_STATE_PRESSED,
  };
  struct wlr_keyboard_key_event unevent = {
      .time_msec = 0,
      .keycode = KEY_W,
      .update_state = true,
      .state = WL_KEYBOARD_KEY_STATE_RELEASED,
  };

  while (1) {
    // wlr_keyboard_notify_key(keyboard, &event);
    wlr_seat_keyboard_notify_key(seat, event.time_msec, event.keycode,
                                 event.state);
    std::this_thread::sleep_for(std::chrono::seconds(1));
    // wlr_keyboard_notify_key(keyboard, &unevent);
    wlr_seat_keyboard_notify_key(seat, unevent.time_msec, unevent.keycode,
                                 unevent.state);
    std::this_thread::sleep_for(std::chrono::seconds(1));
  }
}

int main() {
  wlr_log_init(WLR_DEBUG, NULL);

  auto server = WaylandServer();
  server.start();
  std::cout << "Finished startup" << std::endl;
  std::cout << "Launching keyboard thread!" << std::endl;
  std::thread keyThread(keyboardThread, server.getSeatPointer());
  if (fork() == 0) {
    execl("/bin/sh", "/bin/sh", "-c", "foot", (void *)NULL);
  }
  server.loop();
}
